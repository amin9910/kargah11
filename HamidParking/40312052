from abc import ABC, abstractmethod
from datetime import datetime, timedelta



class Vehicle:
    def __init__(self, size: str, plate: str, time_vorood: datetime = None):
        self.size = size
        self.plate = plate
        self.time_vorood = time_vorood or datetime.now()

    def required_spot_size(self) -> str:
        return self.size


    def can_fit_in_spot(self, spot) -> bool:
        return self.required_spot_size() == spot.size and spot.is_available()

    def calculate_parking_duration(self, exit_time: datetime) -> timedelta:
        return exit_time - self.time_vorood


class Car(Vehicle):
    def __init__(self, plate: str, time_vorood: datetime = None):
        super().__init__('Medium', plate, time_vorood)


class Motorcycle(Vehicle):
    def __init__(self, plate: str, time_vorood: datetime = None):
        super().__init__('Small', plate, time_vorood)


class Truck(Vehicle):
    def __init__(self, plate: str, time_vorood: datetime = None):
        super().__init__('Large', plate, time_vorood)


class ParkingSpot:
    def __init__(self, floor: int, number: int, size: str):
        self.floor = floor
        self.number = number
        self.size = size
        self.vehicle = None


    def is_available(self) -> bool:
        return self.vehicle is None

    def assign_vehicle(self, vehicle: Vehicle) -> bool:
        if vehicle.can_fit_in_spot(self):
            self.vehicle = vehicle
            return True
        return False

    def remove_vehicle(self) -> None:
        self.vehicle = None


class Floor:
    def __init__(self, level: int):
        self.level = level

    def find_available_spot(self, vehicle: Vehicle):
        for spot in self.spots:
            if vehicle.can_fit_in_spot(spot):
                return spot
        return None


    def occupy_spot(self, spot: ParkingSpot, vehicle: Vehicle) -> bool:
        return spot.assign_vehicle(vehicle)

    def vacate_spot(self, spot: ParkingSpot):
        spot.remove_vehicle()


class Reservation:
    def __init__(self, customer, vehicle: Vehicle, spot: ParkingSpot, start: datetime, end: datetime):
        self.customer = customer
        self.vehicle = vehicle
        self.spot = spot
        self.start = start
        self.end = end
        self.checked_in = False
        self.checked_out = False

    def cancel(self):
        self.spot.remove_vehicle()

    def check_in(self, current_time: datetime) -> bool:
        if current_time >= self.start:
            self.checked_in = True
            return True
        return False


    def check_out(self, current_time: datetime) -> timedelta:
        if self.checked_in:
            self.checked_out = True
            self.spot.remove_vehicle()
            return self.vehicle.calculate_parking_duration(current_time)
        return timedelta()


class PricingStrategy(ABC):
    @abstractmethod
    def calculate_fee(self, reservation: Reservation) -> float:
        pass


class FixedRateStrategy(PricingStrategy):
    def __init__(self, rate_per_hour: float):
        self.rate_per_hour = rate_per_hour


    def calculate_fee(self, reservation):
        duration = (reservation.end - reservation.start).total_seconds() / 3600
        return duration * self.rate_per_hour


class PeakHourStrategy(PricingStrategy):
    def __init__(self, base_rate: float, peak_multiplier: float,):
        self.base_rate = base_rate
        self.peak_multiplier = peak_multiplier


    def calculate_fee(self, reservation):
        hours = (reservation.end - reservation.start).total_seconds() / 3600
        peak_hours = sum(1 for h in range(reservation.start.hour, reservation.end.hour) if h in self.peak_hours)
        off_peak_hours = hours - peak_hours
        return (peak_hours * self.base_rate * self.peak_multiplier) + (off_peak_hours * self.base_rate)


class DemandBasedStrategy(PricingStrategy):
    def __init__(self, base_rate: float, parking_lot):
        self.base_rate = base_rate
        self.parking_lot = parking_lot

    def calculate_fee(self, reservation):
        demand = self.parking_lot.get_occupancy_rate()
        return ((reservation.end - reservation.start).total_seconds() / 3600) * self.base_rate * (1 + demand)


def get_pricing_strategy(type: str, parking_lot=None) -> PricingStrategy:
    if type == "fixed":
        return FixedRateStrategy(10.0)
    elif type == "peak":
        return PeakHourStrategy(10.0, 1.5, [8, 9, 17, 18])
    elif type == "demand" and parking_lot:
        return DemandBasedStrategy(10.0, parking_lot)
    else:
        raise ValueError("Unknown pricing strategy")


class PaymentMethod(ABC):
    @abstractmethod
    def process(self, amount: float) -> bool:
        pass


class CreditCardPayment(PaymentMethod):
    def process(self, amount):
        return True


class MobileWalletPayment(PaymentMethod):
    def process(self, amount):
        return True


class CashPayment(PaymentMethod):
    def process(self, amount):
        return True


class ParkingLot:
    _instance = None

    @staticmethod
    def get_instance():
        if ParkingLot._instance is None:
            ParkingLot._instance = ParkingLot()
        return ParkingLot._instance

    def __init__(self):
        if ParkingLot._instance is not None:
            raise Exception("This class is a singleton!")
        self.floors = []
        self.reservations = []

    def add_floor(self, floor: Floor):
        self.floors.append(floor)

    def get_occupancy_rate(self) -> float:
        total = sum(len(floor.spots) for floor in self.floors)
        occupied = sum(1 for floor in self.floors for spot in floor.spots if not spot.is_available())
        return occupied / total if total else 0

    def make_reservation(self, customer, vehicle, start, end) -> Reservation:
        for floor in self.floors:
            spot = floor.find_available_spot(vehicle)
            if spot:
                floor.occupy_spot(spot, vehicle)
                reservation = Reservation(customer, vehicle, spot, start, end)
                self.reservations.append(reservation)
                return reservation
        raise Exception("No available spot")

    def calculate_fee(self, reservation):
        strategy = get_pricing_strategy("fixed")
        return strategy.calculate_fee(reservation)

    def process_payment(self, reservation, method: PaymentMethod):
        amount = self.calculate_fee(reservation)
        return method.process(amount)

    def generate_report(self, format: str):
        reporter = Reporting()
        if format == "csv":
            return reporter.to_csv(self.reservations)
        elif format == "json":
            return reporter.to_json(self.reservations)
        else:
            raise ValueError("Unsupported format")


import csv
from io import StringIO


class Reporting:
    def to_csv(self):
        output = StringIO()
        writer = csv.writer(output)
        writer.writerow(["Customer", "Plate", "Start", "End", "Spot"])
        return output.getvalue()
